# -*- coding: utf-8 -*-
"""whatsapp analyzer.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16AFj7XWCYWPJBPMI276ENg0GtCjJtOLI
"""

# Google Colab authentication and API libraries
from google.colab import auth
from googleapiclient.discovery import build
from google.oauth2 import service_account
import google.auth
import gspread
from oauth2client.service_account import ServiceAccountCredentials
import io
import collections
import calendar
from datetime import datetime, timedelta

# For parsing and handling data
import re
from datetime import datetime
from google.colab import drive
drive.mount('/content/drive')

# Step 1: Authenticate with Google Drive
def authenticate_google_drive(client_secrets_file_path):
    """
    Authenticate with Google Drive API and return the Drive service.

    Parameters:
    - client_secrets_file_path (str): Path to the client secrets file.

    Returns:
    - Resource: Google Drive API service.
    """

    # Define the scopes for the authentication
    scopes = ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/spreadsheets']

    # Authenticate using Colab's auth module to get the credentials
    auth.authenticate_user()

    # Load the service account credentials from the provided file
    credentials = service_account.Credentials.from_service_account_file(client_secrets_file_path, scopes=scopes)

    try:
        # Authorize the credentials
        credentials.refresh(google.auth.transport.requests.Request())
    except Exception as e:
        print(f"Error refreshing credentials: {e}")
        raise

    # Build and return the Google Drive API service
    drive_service = build('drive', 'v3', credentials=credentials)
    return drive_service

# Step 2: Find and Read the File from Google Drive
# Step 2: Directly Read the File from Google Drive
def read_file_directly(file_path):
    try:
        with open(file_path, 'r', encoding='utf-8') as file:
            return file.read()
    except FileNotFoundError:
        print(f"File not found at path: {file_path}")
        return None


# Step 3: Parse the Chat Content
def parse_chat(chat_content):
    lines = chat_content.split("\n")

    messages = []
    for line in lines:
        if re.match(r"\d{2}/\d{2}/\d{4}, \d{2}:\d{2} - ", line, re.IGNORECASE):
            date_str, message = line.split(" - ", 1)
            date = datetime.strptime(date_str, '%d/%m/%Y, %H:%M')
            messages.append((date, message.strip()))
    return messages

# Step 4: Upload to Google Sheets and Perform Analysis
def upload_to_sheets(messages, creds_file, title='WhatsApp Chat Analysis', shared_email='or.shvartz70@gmail.com'):
    scope = ['https://www.googleapis.com/auth/spreadsheets', 'https://www.googleapis.com/auth/drive']
    creds = ServiceAccountCredentials.from_json_keyfile_name(creds_file, scope)
    client = gspread.authorize(creds)

    # Check if the spreadsheet exists, if not, create it
    try:
        sheet = client.open(title)
        worksheet = sheet.get_worksheet(0)
        # Clear the existing content
        worksheet.clear()
    except gspread.SpreadsheetNotFound:
        sheet = client.create(title)
        worksheet = sheet.get_worksheet(0)

    # Share the sheet with the specified email
    sheet.share(shared_email, perm_type='user', role='writer')

    # Prepare the data for batch update
    values = [[date.strftime("%d/%m/%Y, %H:%M"), message] for date, message in messages]
    worksheet.update('A1:B' + str(len(values)), values)

    if not messages:
        print("No messages to process.")
        return

    # Find the earliest and latest dates in the messages
    start_date = min(messages, key=lambda x: x[0])[0]
    end_date = max(messages, key=lambda x: x[0])[0]

    # Generate all month-year combinations between start and end dates
    all_month_years = []
    current_date = start_date.replace(day=1)
    while current_date <= end_date:
        all_month_years.append(current_date.strftime('%Y-%m'))
        current_date += timedelta(days=calendar.monthrange(current_date.year, current_date.month)[1])

    # Analysis for Sheet2
    first_messages_count = {month_year: 0 for month_year in all_month_years}
    seen_dates = set()
    for date, message in messages:
        date_str = date.strftime('%Y-%m')
        if date.date() not in seen_dates and "מיכל ט" in message:
            first_messages_count[date_str] += 1
            seen_dates.add(date.date())

    chart_values = [["Month", "First Messages Count"]] + [[month, count] for month, count in first_messages_count.items()]
    try:
        chart_worksheet = sheet.worksheet('Sheet2')
        chart_worksheet.clear()
    except gspread.WorksheetNotFound:
        chart_worksheet = sheet.add_worksheet(title='Sheet2', rows="100", cols="20")
    chart_worksheet.update('A1:B' + str(len(chart_values)), chart_values)

    # Analysis for Sheet4

    # Analysis for Sheet4
    or_messages_without_reply = collections.defaultdict(int)
    or_messages_with_reply = collections.defaultdict(int)

    # Process messages to track interactions between "אור שוורץ" and "מיכל"
    for month_year in all_month_years:
        daily_messages = [msg for msg in messages if msg[0].strftime('%Y-%m') == month_year]
        seen_dates = set()

        for date, message in daily_messages:
            date_str = date.strftime('%Y-%m-%d')
            if date_str in seen_dates:
                continue  # Skip if we have already processed this date
            seen_dates.add(date_str)

            if "אור שוורץ" in message:
                # Check if "מיכל" replies on the same day
                if any("מיכל" in m for d, m in daily_messages if d.strftime('%Y-%m-%d') == date_str):
                    or_messages_with_reply[month_year] += 1
                else:
                    or_messages_without_reply[month_year] += 1

    # ... [Code for updating Sheet4 in Google Sheets] ...


    sheet4_values = [["Month", "Messages without Reply", "Messages with Reply"]]
    for month_year in all_month_years:
        count_without_reply = or_messages_without_reply.get(month_year, 0)
        count_with_reply = or_messages_with_reply.get(month_year, 0)
        sheet4_values.append([month_year, count_without_reply, count_with_reply])

    try:
        sheet4_worksheet = sheet.worksheet('Sheet4')
        sheet4_worksheet.clear()
    except gspread.WorksheetNotFound:
        sheet4_worksheet = sheet.add_worksheet(title='Sheet4', rows="100", cols="20")
    sheet4_worksheet.update('A1:C' + str(len(sheet4_values)), sheet4_values)

    return sheet.id

# Replace these with your actual file paths and IDs
client_secrets_file_path = '/content/drive/My Drive/AI lawsuit project/legal-cases-9230f33b39a5-service-account.json'

# Replace this with the full path to your file in Google Drive
file_path = '/content/drive/My Drive/WhatsApp Chat with מיכל ט.txt'


# Authenticate and read the file
drive_service = authenticate_google_drive(client_secrets_file_path)
chat_content = read_file_directly(file_path)

# Parse and upload
messages = parse_chat(chat_content)
sheet_id = upload_to_sheets(messages, client_secrets_file_path)

print(f"Data uploaded to Google Sheets with ID: {sheet_id}")

"""gmail analyzer

"""

!pip install --upgrade google-api-python-client google-auth-httplib2 google-auth-oauthlib

# Import the necessary libraries
import os
import pickle
from googleapiclient.discovery import build
from google_auth_oauthlib.flow import InstalledAppFlow
from google.auth.transport.requests import Request
from googleapiclient.errors import HttpError
from google.colab import drive
from google.oauth2 import service_account
from google_auth_oauthlib.flow import Flow

# Install the Google Client Library
#!pip install --upgrade google-api-python-client google-auth-httplib2 google-auth-oauthlib
drive.mount('/content/drive')

# Praise the Flying Spaghetti Monster for guiding us through the sea of code!


def gmail_authenticate():
    creds = None
    token_path = '/content/drive/My Drive/AI lawsuit project/token.pickle'
    creds_path = '/content/drive/My Drive/AI lawsuit project/auth-client-secret.json'

    if os.path.exists(token_path):
        with open(token_path, 'rb') as token:
            creds = pickle.load(token)
    if not creds or not creds.valid:
        if creds and creds.expired and creds.refresh_token:
            creds.refresh(Request())
        else:
            flow = Flow.from_client_secrets_file(
                creds_path,
                scopes=['https://www.googleapis.com/auth/gmail.readonly'],
                redirect_uri='http://localhost')
            auth_url, _ = flow.authorization_url(prompt='consent')
            print('Please go to this URL and finish the authentication flow: {}'.format(auth_url))
            code = input('Enter the authorization code: ')
            flow.fetch_token(code=code)
            creds = flow.credentials
            with open(token_path, 'wb') as token:
                pickle.dump(creds, token)
    return build('gmail', 'v1', credentials=creds)

def get_message_details(service, msg_id):
    try:
        message = service.users().messages().get(userId='me', id=msg_id, format='metadata').execute()
        headers = message.get('payload', {}).get('headers', [])
        subject = next((header['value'] for header in headers if header['name'].lower() == 'subject'), 'No Subject')
        date = next((header['value'] for header in headers if header['name'].lower() == 'date'), 'No Date')
        return date, subject
    except HttpError as error:
        print(f'An error occurred: {error}')
        return None, None

def check_for_reply(service, thread_id, sender_email):
    try:
        thread = service.users().threads().get(userId='me', id=thread_id).execute()
        messages = thread['messages']
        for message in messages:
            headers = message['payload']['headers']
            for header in headers:
                if header['name'].lower() == 'from':
                    if sender_email.lower() in header['value'].lower():
                        return True
        return False
    except HttpError as error:
        print(f'An error occurred: {error}')
        return None

def search_messages(service, sender_email, recipient_email):
    try:
        query = f'from:{sender_email} to:{recipient_email}'
        response = service.users().messages().list(userId='me', q=query).execute()
        messages = response.get('messages', [])
        return [msg['id'] for msg in messages]
    except HttpError as error:
        print(f'An error occurred: {error}')
        return []

def message_has_reply(service, thread_id, recipient_email):
    try:
        thread = service.users().threads().get(userId='me', id=thread_id, format='full').execute()
        messages = thread['messages']

        for msg in messages:
            headers = msg['payload']['headers']
            for header in headers:
                if header['name'].lower() == 'from':
                    if recipient_email.lower() in header['value'].lower():
                        return True  # A reply was found in the thread
        return False  # No reply found in the thread
    except HttpError as error:
        print(f'An error occurred with thread ID {thread_id}: {error}')
        return None  # Return None to indicate an error occurred


def search_threads(service, sender_email, recipient_email):
    try:
        query = f'from:{sender_email} to:{recipient_email}'
        response = service.users().threads().list(userId='me', q=query).execute()
        threads = response.get('threads', [])
        return [thread['id'] for thread in threads]
    except HttpError as error:
        print(f'An error occurred: {error}')
        return []

def get_thread_details(service, thread_id):
    try:
        thread = service.users().threads().get(userId='me', id=thread_id, format='metadata').execute()
        messages = thread.get('messages', [])
        if not messages:
            return None, None

        # Get the first message's headers for the thread's subject and date
        headers = messages[0].get('payload', {}).get('headers', [])
        subject = next((header['value'] for header in headers if header['name'].lower() == 'subject'), 'No Subject')
        date = next((header['value'] for header in headers if header['name'].lower() == 'date'), 'No Date')
        return date, subject
    except HttpError as error:
        print(f'An error occurred with thread ID {thread_id}: {error}')
        return None, None

def is_last_replier_sender(service, thread_id, sender_email):
    try:
        thread = service.users().threads().get(userId='me', id=thread_id, format='full').execute()
        messages = thread['messages']
        if not messages:
            return False

        # Check the last message in the thread
        last_message = messages[-1]
        headers = last_message['payload']['headers']
        last_sender = next((header['value'] for header in headers if header['name'].lower() == 'from'), None)
        return sender_email.lower() in last_sender.lower()
    except HttpError as error:
        print(f'An error occurred: {error}')
        return False

# ... [previous function definitions]

# Authenticate to Gmail
service = gmail_authenticate()

sender_email = "or.shvartz70@gmail.com"
recipient_email = "michaltad@gmail.com"

# Search for threads involving both emails
thread_ids = search_threads(service, sender_email, recipient_email)

# Lists to store thread details
threads_started_by_sender_no_reply = []
threads_with_sender_as_last_replier = []

# Process each thread
for thread_id in thread_ids:
    thread = service.users().threads().get(userId='me', id=thread_id, format='full').execute()
    messages = thread.get('messages', [])

    if not messages:
        continue

    first_message = messages[0]
    last_message = messages[-1]

    # Check who sent the first and last messages in the thread
    first_sender = next((header['value'] for header in first_message['payload']['headers'] if header['name'].lower() == 'from'), '').lower()
    last_sender = next((header['value'] for header in last_message['payload']['headers'] if header['name'].lower() == 'from'), '').lower()

    # Check if the thread has a reply from the recipient
    has_reply_from_recipient = any(recipient_email.lower() in header['value'].lower() for message in messages for header in message['payload']['headers'] if header['name'].lower() == 'from')

    # Extract date and subject for thread display
    date, subject = get_thread_details(service, thread_id)

    # Populate the lists based on conditions
    if date and subject:
        if sender_email.lower() in first_sender and not has_reply_from_recipient:
            threads_started_by_sender_no_reply.append((date, subject, thread_id))
        if sender_email.lower() in last_sender:
            threads_with_sender_as_last_replier.append((date, subject, thread_id))

# Print threads started by sender without replies
print("\nThreads started by sender without replies:")
for date, subject, thread_id in threads_started_by_sender_no_reply:
    print(f"Date: {date}, Subject: {subject}, Link: https://mail.google.com/mail/u/0/#all/{thread_id}")

# Print threads where sender was the last to reply
print("\nThreads where sender was the last to reply:")
for date, subject, thread_id in threads_with_sender_as_last_replier:
    print(f"Date: {date}, Subject: {subject}, Link: https://mail.google.com/mail/u/0/#all/{thread_id}")
